package  {		import flash.events.*;	import HeroObject;	import flash.display.*;	import Utils;		public class CalcHero {		public function CalcHero() {			// constructor code					}				// VARIABLES		private var intro: Array;		private var outro: Array;		private var batmanAngriff:Array;		private var batmanAbwehr:Array;		private var supermanAngriff:Array;		private var supermanAbwehr:Array;		private var usedVideos:Array;		//private var usedVideosBatman:Array = new Array;		//private var usedVideosSuperman:Array = new Array;		private var strategyForReaction:String;		private var strategyCurrent:String;		private var skipReaction:Boolean;		private var thisClipName:String;				private var playList: Array;		private var videoObjects: Array;		private var loopCounter:int;				private var testArray:Array = new Array();		private var objectToRemove:Array;		private var nextTags:Object;		private var oldSubject:Array;		private var newSubject:Array;		private var oldPrimSubject:String;		private var thisClips:Array = new Array();						//FUNKTIONSVARIABLEN		private var randNum:int;		private var currentGroup:int;		// 1 = Superman(pro); 2 = Batman(contra)		private var currentRoleReaction:int;		private var currentRoleArgument:int;		private var primarySubject:String;		private var listOfAvailablePrimSubs:Array = new Array();		private const primarySubjects:Array = ["philosophy","science","egotism/altruism","philanthropy/misanthropy",													 "ethic","religion","politics","power","war/peace","society","ratio",													 "nature","idealism","economy","psychology","art","misc"];		private var currentSecondarySubjects:Array;		private var currentPrimarySubject:String;				// Save calculated MeatObjects in this Array for use in Debug TextField		public var metaList: Array;						public function calculateClips(xml:XMLList): Array {			playList = new Array ();			videoObjects = new Array ();			intro = new Array();			outro = new Array();			batmanAngriff = new Array();			batmanAbwehr = new Array();			supermanAngriff = new Array();			supermanAbwehr = new Array();			usedVideos = new Array();			metaList = new Array();						//Videoobjecte parsen und in Array legen			for (var i:int = 0; i<xml.length(); i++)			{				videoObjects[i] = new HeroObject (i,												  xml[i].user_id.text(),												  xml[i].clipname.text(),												  xml[i].strategy.text(),												  xml[i].dramaturgy.text(),												  xml[i].pro_contra.text(),												  xml[i].attack_reaction.text(),												  xml[i].primary_subject.text(),												  xml[i].philosophy.text(),												  xml[i].science.text(),												  xml[i].egotism_altruism.text(),												  xml[i].philanthropy_misanthropy.text(),												  xml[i].ethic.text(),												  xml[i].religion.text(),												  xml[i].politics.text(),												  xml[i].power.text(),												  xml[i].war_peace.text(),												  xml[i].society.text(),												  xml[i].ratio.text(),												  xml[i].nature.text(),												  xml[i].idealism.text(),												  xml[i].economy.text(),												  xml[i].psychology.text(),												  xml[i].art.text(),												  xml[i].misc.text(),												  xml[i].exception.text()												  );								//Intro				if(videoObjects[i].dramaturgy == "intro"){					intro.push(videoObjects[i]);					trace(videoObjects[i].clipname);					trace(videoObjects[i].user_id);				}								//Outro				if(videoObjects[i].dramaturgy == "outro"){					outro.push(videoObjects[i]);					trace(videoObjects[i].clipname);					trace(videoObjects[i].user_id);				}								// Sortiere Superman Angriff und Abwehr				if(videoObjects[i].pro_contra == "pro" && videoObjects[i].dramaturgy != "intro"){					if(videoObjects[i].attack_reaction == "attack"){						supermanAngriff.push(videoObjects[i])					}else{						supermanAbwehr.push(videoObjects[i]);					}				}												// Sortiere Batman Angriff und Abwehr				if(videoObjects[i].pro_contra == "contra" && videoObjects[i].dramaturgy != "intro"){					if(videoObjects[i].attack_reaction == "attack"){						batmanAngriff.push(videoObjects[i])					}else{						batmanAbwehr.push(videoObjects[i]);					}				}			}						currentRoleArgument = 1; // Entscheided wer anfängt  1 = Batman fängt an; 2 = Superman fängt an			//currentRoleReaction = 2; // Entscheided wer als erster reagiert 1 = Batman reagiert; 2 = Superman reagiert			//currentPrimarySubject = primarySubjects[Utils.randRound(primarySubjects.length)]; // wähle erstes Primäres Thema (Primäre Themenauswahl ist die gleiche wie die Sek. Themenauswahl)			//oldSubject = primarySubjects[Utils.randRound(primarySubjects.length)];			//trace("--- " + currentPrimarySubject + " ---");						//-----ASSEMBLE PLAYLIST--------						//intro			playList.push(intro[0].getClipName); // only one intro should be in the array			metaList.push(intro[0]);			playList.push(firstArgument().getClipName);			Utils.remove(objectToRemove, randNum);			playList.push(reactionFunc().getClipName);			Utils.remove(objectToRemove, randNum);						//main			for(var i:int = 0; i < 10; i++){				thisClipName = argumentFunc().getClipName;				playList.push(thisClipName);								if(currentRoleArgument == 2)removeWithName(thisClipName, batmanAngriff);				else removeWithName(thisClipName, supermanAngriff);								//Utils.remove(objectToRemove, randNum);				if(skipReaction){					if(playList.length -2 != 0){ // don't splice intro						var spliced:Array = playList.splice(playList.length -2, 1); //entferne vorhergehnde Abwehr aus Playlist						metaList.splice(metaList.length -2, 1); //entferne vorhergehnde Abwehr aus Metalist für Debugversion						trace(spliced);						trace("spliced");					}				}				playList.push(reactionFunc().getClipName);				Utils.remove(objectToRemove, randNum);			}						//outro			playList.push(outro[0].getClipName); // only one outro should be in the array			metaList.push(outro[0]);						trace("------------------------------");			trace(playList);			return playList;		}						//FUNKTIONEN				//////////////		//1. ARGUMENT		//////////////				private function firstArgument():HeroObject		{			skipReaction = false;			if(currentRoleArgument == 1)			{				randNum = Utils.randRound(batmanAngriff.length);				oldSubject = getSubjects(batmanAngriff[randNum]);				oldPrimSubject = batmanAngriff[randNum].getPrimarySubject;				trace("oldPrimSub: " + oldPrimSubject);								strategyForReaction = batmanAngriff[randNum].getStrategy;				currentPrimarySubject = batmanAngriff[randNum].getPrimarySubject;				if(batmanAngriff[randNum].getException == "true") skipReaction = true;				currentRoleArgument = 2; // 2 = Batman				metaList.push(batmanAngriff[randNum]);				objectToRemove = batmanAngriff;				return batmanAngriff[randNum];			}			else			{				randNum = Utils.randRound(supermanAngriff.length);				oldSubject = getSubjects(supermanAngriff[randNum]);				oldPrimSubject = supermanAngriff[randNum].getPrimarySubject;				strategyForReaction = supermanAngriff[randNum].getStrategy;				currentPrimarySubject = supermanAngriff[randNum].getPrimarySubject;				if(batmanAngriff[randNum].getException == "true") skipReaction = true;				currentRoleArgument = 2; // 2 = Batman				metaList.push(supermanAngriff[randNum]);				objectToRemove = supermanAngriff;				return supermanAngriff[randNum];			}					}				///////////		//ARGUMENT		///////////				private function argumentFunc():HeroObject{			skipReaction = false;			loopCounter = 0; // wird gebraucht, da der loop sonst nicht beendet wird, da für manche themen zu wenig videos vorhanden sind			if(currentRoleArgument == 1){	// falls Superman anfängt lass Batman folgen												thisClips = theRules(oldSubject, batmanAngriff, oldPrimSubject, 5);				randNum = Utils.randRound(thisClips.length);								oldSubject = getSubjects(thisClips[randNum]);				oldPrimSubject = thisClips[randNum].getPrimarySubject;								strategyForReaction = thisClips[randNum].getStrategy;				currentPrimarySubject = thisClips[randNum].getPrimarySubject;				if(thisClips[randNum].getException == "true") skipReaction = true;								//strategyForReaction = batmanAngriff[randNum].getStrategy;				//currentPrimarySubject = batmanAngriff[randNum].getPrimarySubject;				//if(batmanAngriff[randNum].getException == "true") skipReaction = true;																				currentRoleArgument = 2; // 2 = Batman				metaList.push(thisClips[randNum]);				//objectToRemove = batmanAngriff;				return thisClips[randNum];											}else{ //FÜR SUPERMAN							thisClips = theRules(oldSubject, supermanAngriff, oldPrimSubject, 5);				randNum = Utils.randRound(thisClips.length);								oldSubject = getSubjects(thisClips[randNum]);				oldPrimSubject = thisClips[randNum].getPrimarySubject;								strategyForReaction = thisClips[randNum].getStrategy;				currentPrimarySubject = thisClips[randNum].getPrimarySubject;				if(thisClips[randNum].getException == "true") skipReaction = true;																currentRoleArgument = 1; // 1 = Superman				metaList.push(thisClips[randNum]);				//objectToRemove = supermanAngriff;				return thisClips[randNum];			}			return "ERROR IN ARGUMENTFUNC";		}						///////////		//REAKTION		///////////				private function reactionFunc():HeroObject{			if(currentRoleReaction == 1){				do				{					randNum = Utils.randRound(batmanAbwehr.length);					strategyCurrent = batmanAbwehr[randNum].getStrategy;				}				while(strategyForReaction != strategyCurrent); // make sure that the same strategy as in the prior Argument is used				currentRoleReaction = 2; // 2 = Batman				metaList.push(batmanAbwehr[randNum]);				objectToRemove = batmanAbwehr;				return batmanAbwehr[randNum];			}else{				do				{					randNum = Utils.randRound(supermanAbwehr.length);					strategyCurrent = supermanAbwehr[randNum].getStrategy;				}				while(strategyForReaction != strategyCurrent) // make sure that the same strategy as in the prior Argument is used									currentRoleReaction = 1; // 1 = Superman				metaList.push(supermanAbwehr[randNum]);				objectToRemove = supermanAbwehr;				return supermanAbwehr[randNum];			}			return "ERROR IN REACTIONFUNC";		}				/*		private function checkIfUsed(thisClipName:String):Boolean{			for(var i:int = 0; i < usedVideos.length; i++){				if(thisClipName == usedVideos[i]){					trace("used");					return true;				}			}			return false;		}				private function checkIfClipUsed(clipName:String, indexNum:int):Boolean{			if(indexNum == 1){ // 1 = supermanAngriff; 2 = batmanAngriff				if(checkForDuplicateClips(usedVideosSuperman, clipName))				return true;			}else{				if(checkForDuplicateClips(usedVideosBatman, clipName))				return false;			}			return false;					}				private function checkForDuplicateClips(array1:Array, nameToCheck:String):Boolean{			for(var i:int = 0; i < array1.length; i++){				if(array1[i] == nameToCheck){					return true;				}else return false;			}			return false;		}*/						/*private function checkIfUsed(num:int, indexNum:int):Boolean{			if(indexNum == 1){ // 1 = supermanAngriff; 2 = batmanAngriff				if(checkForDuplicates(usedVideosSuperman, num))				return true;			}else{				if(checkForDuplicates(usedVideosBatman, num))				return false;			}			return false;		}				private function checkForDuplicates(array1:Array, numToCheck:int):Boolean{			for(var i:int = 0; i < array1.length; i++){				if(array1[i] == numToCheck){					return true;				}else return false;			}			return false;		}*/						//DIE 6 REGELN FUNKTION				private function getSubjects(object:HeroObject):Array		{			//var tags:Dictionary;			var numSubjects:int;			var thisSubjects:Array = new Array();			var thisTags:Object = {								philosophy:object.getPhilosophy,								science:object.getScience,								egotism:object.getEgotism,								philan:object.getPhilan,								economy:object.getEconomy,								psychology:object.getPsychology,								religion:object.getReligion,								politicy:object.getPolitics,								power:object.getPower,								war:object.getWar,								society:object.getSociety,								ratio:object.getRatio,								nature:object.getNature,								idealism:object.getIdealism,								ethic:object.getEthic,								art:object.getArt,								misc:object.getMisc							};										//nextTags = thisTags;						//check wich tags are true and put the subject in array			for (var key:Object in thisTags)			{				//trace(key);				if(thisTags[key] == "true")				{					//trace(key + ": " + thisTags[key]);					thisSubjects.push(key);				}				//delete currentSubject[key];			}			// get number of subjects for this video			numSubjects = thisSubjects.length;			//trace("Anzahl aktivierter Tags: " + numSubjects)			///trace("numSubjects: " + numSubjects + ": " + thisSubjects);			return thisSubjects;					}						private function checkSecondarySubjects(newSub:Array, oldSub:Array):int		{			var makeThisNewSubject:Array = new Array();			var same:Array = new Array();			var different:Array = new Array();						for(var i:int = 0; i< newSub.length; i++){				for(var j:int = 0; j< oldSub.length; j++){					if(newSub[i] == oldSub[j]){						//trace(array1[i] + " and " + array2[j]);						same.push(oldSub[j]);					}else different.push(oldSub[j]);				}			}			//trace("Gleiche Sekundärtags: " + same.length);			if(same.length == 2) return 2;			else if(same.length == 1) return 1;			else if(same.length == 0) return 0;			else return -1; // sollte nicht vorkommen		}				////////////		//THE RULES		////////////				private function theRules(oldSub:Array, wholeArray:Array, primSub:String, randNum:int):Array{						var samePrim:Array = new Array();			var sameSec:Array = new Array();			var secSub:Array = new Array();			var theSame:Array = new Array();			var rule1:Array = new Array();			var rule2:Array = new Array();			var rule3:Array = new Array();			var rule4:Array = new Array();			var rule5:Array = new Array();			var rule6:Array = new Array();						trace("entered the rules function");			trace("vorhergehendes primär Thema: " + primSub);			trace("--------------------------------------");						for(var i:int = 0; i < wholeArray.length; i++)			{				//if(wholeArray[i].getClipName != wholeArray[randNum].getClipName) // verhindert das vorhergehende				//{					//trace(wholeArray[i].getPrimarySubject);										if(wholeArray[i].getPrimarySubject == primSub) 					{						secSub = getSubjects(wholeArray[i]);						var numSecondarySame = checkSecondarySubjects(secSub, oldSub); // überprüfen																		if(numSecondarySame == 2)						{							rule1.push(wholeArray[i]);							//trace("- RULE 1");						}						else if(numSecondarySame == 1)						{							rule2.push(wholeArray[i]);							//trace("- RULE 2");						}						else if(numSecondarySame == 0)						{							rule4.push(wholeArray[i]);							//trace("- RULE 4");						}					}					else					{						secSub = getSubjects(wholeArray[i]);						var numSecondarySame = checkSecondarySubjects(secSub, oldSub);												if(numSecondarySame == 2)						{							rule6.push(wholeArray[i]);							//trace("- RULE 6");						}						if(numSecondarySame == 1)						{							rule3.push(wholeArray[i]);							//trace("- RULE 3");						}						if(numSecondarySame == 0)						{							rule5.push(wholeArray[i]);							//trace("- RULE 5");						}					}							}						if(rule1.length != 0)			{				trace("RULE 1");				return rule1;			}			else if (rule2.length != 0)			{				trace("RULE 2");				return rule2;			}			else if (rule3.length != 0)			{				trace("RULE 3");				return rule3;			}			else if (rule4.length != 0)			{				trace("RULE 4");				return rule4;			}			else if (rule5.length != 0)			{				trace("RULE 5");				return rule5;			}			else if (rule6.length != 0)			{				trace("RULE 6");				return rule6;			}			else return intro; // return intro if error		}				private function checkSubjectList(objectToCheck:HeroObject): void {			var subjectList:Array = new Array ();			currentSecondarySubjects = new Array();			subjectList.push(objectToCheck.getPhilosophy);			subjectList.push(objectToCheck.getScience);			subjectList.push(objectToCheck.getEgotism);			subjectList.push(objectToCheck.getPhilan);			subjectList.push(objectToCheck.getEconomy);					subjectList.push(objectToCheck.getPsychology);			subjectList.push(objectToCheck.getReligion);			subjectList.push(objectToCheck.getPolitics);			subjectList.push(objectToCheck.getPower);			subjectList.push(objectToCheck.getWar);			subjectList.push(objectToCheck.getSociety);			subjectList.push(objectToCheck.getRatio);			subjectList.push(objectToCheck.getNature);			subjectList.push(objectToCheck.getIdealism);			subjectList.push(objectToCheck.getEconomy);			subjectList.push(objectToCheck.getArt);			subjectList.push(objectToCheck.getMisc);			subjectList.push(objectToCheck.getException);									/*for(var i:uint = 0; i< subjectList.length; i++){				trace(subjectList[i]);			}*/						for(var i:uint = 0; i< primarySubjects.length; i++){				if(subjectList[i] == "true"){					currentSecondarySubjects.push(primarySubjects[i]);				}			}		}				//1. Regel: Suche nach "perfect fit"		private function checkPrimarySubject(array1:Array, currentPrSubj:String):Array{			listOfAvailablePrimSubs = new Array();			for(var i:int = 0; i < array1.length; i++){				if(array1[i].getPrimarySubject == currentPrSubj){										listOfAvailablePrimSubs.push(array1[i]);				}			}						return listOfAvailablePrimSubs;		}				private function removeWithName(clipName:String, removeFromThis:Array):void		{			for(var i:int = 0; i < removeFromThis.length; i++)			{				if(removeFromThis[i].getClipName == clipName)				{					removeFromThis.splice(i, 1);				}			}		}				/*private function compareSubjects(array1:Array, array2:Array): Boolean{			makeThisSubject = new Array();			nextSubject = new Array();			//check for similar items in both arrays and create an array that will determine the Subject to be played and the next subject			for(var i:int = 0; i< array1.length; i++){				for(var j:int = 0; j< array2.length; j++){					if(array1[i] == array2[j]){						//trace(array1[i] + " and " + array2[j]);						makeThisSubject.push(array2[j]);					}else nextSubject.push(array2[j]);				}											}			// remove similar items from array so the next subject won't be the same as it already is			for(var i:int = 0; i< nextSubject.length; i++){				if(nextSubject[i] == makeThisSubject[0]){					nextSubject.splice(i,1);				}			}			//check if similar objects were found and return true otherwise return false			if(makeThisSubject.length == 0){				return false;			}else{				return true;			}		}*/	}	}