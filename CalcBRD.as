////////////////*TO DO:- [SOLVED]Welches Kameramuster?- [SOLVED]Wer startet?- Am Anfang nur AH und AV (fast fertig)- Intro/Outro Kamera mit Clip nachfolgend/davor anpassen- Kameravarianz*////////////////package  {		import flash.events.*;	import flash.display.*;	import flash.utils.Dictionary;	import Player;	import BRDObject;	import Utils;	import flash.accessibility.Accessibility;		public class CalcBRD {		public function CalcBRD() {			// constructor code		}				/////////////		//VARIABLES//		/////////////				//most important		private var randNum:int;				//Intro		private var intro:Array;		//Outro		private var outro:Array;				//ARRAYS		private var playList:Array;		private var videoObjects:Array;		public var metaList:Array;				private var brdAction:Array;		private var ddrAction:Array;		private var brdReaction:Array;		private var ddrReaction:Array;		private var brdReturn:Array;		private var ddrReturn:Array;				//for beginning of playlist		private var ddrActionStart:Array;		private var ddrActionEnd:Array;		private var brdActionStart:Array;		private var brdActionEnd:Array;				private var listOfFilteredObjects:Array;				//BOOLEANS		private var isDDR:Boolean;		private var isCloseUp:Boolean;		private var isReactionToQuestion:Boolean;		private var isReturnQuestion:Boolean;		private var isOnlyAHandAV:Boolean; // Regel 5. Am Anfang nur AR und AV Regel 6. Nach dem "const numSpeakerChange:int" kommen AH uns SH dazu		private var skipCamToggle:Boolean;				//STRINGS		private var strategyReaction:String;		private var strategyReturn:String;		private var strategyArgument:String;		private var clipNameOfObjectToRemove:String;		private var strategy:String;				//INT		private const numSpeakerChange:int = 4;				//OBJECTS		private var subjects:Object;		private var nextStrategy:Object;						public function calculateClips(xml:XMLList): Array 		{			playList = new Array ();			videoObjects = new Array ();			Utils.allFilesNames = new Array();			metaList = new Array();			intro = new Array();			outro = new Array();			brdAction = new Array();			ddrAction = new Array();			brdReaction = new Array();			ddrReaction = new Array();			brdReturn = new Array();			ddrReturn = new Array();			listOfFilteredObjects = new Array();			isReturnQuestion = false;			isOnlyAHandAV = true;						ddrActionStart = new Array();			ddrActionEnd = new Array();			brdActionStart = new Array();			brdActionEnd = new Array();						for (var i:int = 0; i<xml.length(); i++)			{				videoObjects[i] = new BRDObject (i,												 xml[i].subgroup.text(),												 xml[i].clipname.text(),												 xml[i].dramaturgy.text(),												 xml[i].role.text(),												 xml[i].strategy.text(),												 xml[i].ad_rem.text(),												 xml[i].ad_ver.text(),												 xml[i].ad_hom.text(),												 xml[i].shifting.text(),												 xml[i].play_pos.text(),												 xml[i].shot.text(),												 xml[i].combination.text(),												 xml[i].society.text(),												 xml[i].worldview.text(),												 xml[i].culture.text(),												 xml[i].government.text()												 );								Utils.allFilesNames.push(videoObjects[i].getClipName);								if(videoObjects[i].getDramaturgy == "outro") outro.push(videoObjects[i]);				if(videoObjects[i].getDramaturgy == "intro") 				{					intro.push(videoObjects[i]);				}								if(videoObjects[i].getRole == "brd" && videoObjects[i].getDramaturgy != "intro" && videoObjects[i].getDramaturgy != "outro")				{					if(videoObjects[i].getDramaturgy == "argument") 					{						if(videoObjects[i].getPlayPos == "start") brdActionStart.push(videoObjects[i]);						else if(videoObjects[i].getPlayPos == "end") brdActionEnd.push(videoObjects[i]);						else brdAction.push(videoObjects[i]);					}					else if(videoObjects[i].getDramaturgy == "reaction" || videoObjects[i].getDramaturgy == "reaction_to_question") brdReaction.push(videoObjects[i]);					else if(videoObjects[i].getDramaturgy == "return" || videoObjects[i].getDramaturgy == "return_question") brdReturn.push(videoObjects[i]);				}				if(videoObjects[i].getRole == "ddr" && videoObjects[i].getDramaturgy != "intro" && videoObjects[i].getDramaturgy != "outro")				{					if(videoObjects[i].getDramaturgy == "argument") 					{						if(videoObjects[i].getPlayPos == "start") ddrActionStart.push(videoObjects[i]);						else if(videoObjects[i].getPlayPos == "end") ddrActionEnd.push(videoObjects[i]);						else ddrAction.push(videoObjects[i]);					}					else if(videoObjects[i].getDramaturgy == "reaction" || videoObjects[i].getDramaturgy == "reaction_to_question") ddrReaction.push(videoObjects[i]);					else if(videoObjects[i].getDramaturgy == "return" || videoObjects[i].getDramaturgy == "return_question") ddrReturn.push(videoObjects[i]);				}			}						//ASSEMBLING PLAYLIST////////////////////////////////////////////////////////////////////////////////						//determine who starts			//isDDR = Utils.randRound(2) // 			isDDR = true;			skipCamToggle = false;			//determine camera shot			//isCloseUp = Utils.randRound(2);						//INTRO			if(intro.length != 0) 			{				randNum = Utils.randRound(intro.length);				playList.push(intro[randNum].getClipName);				metaList.push(intro[randNum]);				if(intro[randNum].getShot == "medium") isCloseUp = true;				else isCloseUp = false;			}						// FIRST ARGUMENT AND STARTCLIPS			playList.push(firstArgument().getClipName);			playList.push(returnTo().getClipName);			playList.push(reaction().getClipName);			isCloseUp ? isCloseUp = false : isCloseUp = true;			playList.push(firstArgument().getClipName);						//PLAYLIST			for(var i:int = 0; i < 8; i++)			{				playList.push(returnTo().getClipName);				skipCamToggle = Utils.randRound(2);				playList.push(reaction().getClipName);				playList.push(argument().getClipName);				if(i >= numSpeakerChange) isOnlyAHandAV = false;			}						// ENDCLIPS			playList.push(returnTo().getClipName);			playList.push(reaction().getClipName);			isCloseUp ? isCloseUp = false : isCloseUp = true;			playList.push(lastArgument().getClipName);			playList.push(returnTo().getClipName);			playList.push(reaction().getClipName);			isCloseUp ? isCloseUp = false : isCloseUp = true;			playList.push(lastArgument().getClipName);						//OUTRO			if(outro.length != 0) 			{				playList.push(outroFunction().getClipName);			}						////////////////////////////////////						trace("----------");			Utils.checkForDuplicates(playList);			//trace(playList);			return playList;		}				//////////////////		//MAIN FUNCTIONS//		//////////////////			// FIRST ARGUMENT				private function firstArgument():BRDObject		{			trace("firsArgument Close?: " + isCloseUp);			if(isDDR)				return firstAndLastArgumentFunction(ddrActionStart, isCloseUp);			else				return firstAndLastArgumentFunction(brdActionStart, isCloseUp);		}				private function lastArgument():BRDObject		{			if(isDDR)				return firstAndLastArgumentFunction(ddrActionEnd, isCloseUp);			else				return firstAndLastArgumentFunction(brdActionEnd, isCloseUp);		}				private function returnTo():BRDObject		{			//switch camera shot			isCloseUp ? isCloseUp = false : isCloseUp = true;			//skipCamToggle = Utils.randRound(2); //if 1 next Cam will have same shot if 0 Cam will change						if(isDDR)			{				isDDR = false;				return returnToFunction(ddrReturn, isCloseUp);			}			else			{				isDDR = true;				return returnToFunction(brdReturn, isCloseUp);			}		}						private function reaction():BRDObject		{			//switch camera shot			if(!skipCamToggle) isCloseUp ? isCloseUp = false : isCloseUp = true;			//trace("reaction Close?: " + isCloseUp);						if(isDDR)				return reactionFunction(ddrReaction, isCloseUp);			else				return reactionFunction(brdReaction, isCloseUp);		}								private function argument():BRDObject		{						//switch camera shot			isCloseUp ? isCloseUp = false : isCloseUp = true;			//trace("argument Close?: " + isCloseUp);			if(isDDR)				return argumentFunction(ddrAction, isCloseUp);			else				return argumentFunction(brdAction, isCloseUp);		}						/////////////		//THE HEART//		/////////////				private function outroFunction():BRDObject		{			var matchingOutros:Array = new Array;			if(!isDDR)			{				if(isCloseUp)				{					for(var i:int = 0; i < outro.length; i++)					{						if(outro[i].getRole == "ddr" && "close" == outro[i].getShot)						{							matchingOutros.push(outro[i]);						}					}				}				else				{					for(var i:int = 0; i < outro.length; i++)					{						if(outro[i].getRole == "ddr" && "medium" == outro[i].getShot)						{							matchingOutros.push(outro[i]);						}					}				}			}			else			{				if(isCloseUp)				{					for(var i:int = 0; i < outro.length; i++)					{						if(outro[i].getRole == "brd" && "close" == outro[i].getShot)						{							matchingOutros.push(outro[i]);						}					}				}				else				{					for(var i:int = 0; i < outro.length; i++)					{						if(outro[i].getRole == "brd" && "medium" == outro[i].getShot)						{							matchingOutros.push(outro[i]);						}					}				}			}						randNum = Utils.randRound(matchingOutros.length);			metaList.push(matchingOutros[randNum]);			return matchingOutros[randNum];		}					// FIRST ARGUMENT FUNCTION 				private function firstAndLastArgumentFunction(objectArray:Array, bShot:Boolean):BRDObject		{			var matchingObjects:Array = new Array();						//sort for matching camera shot			if(bShot)			{				for(var i:int = 0; i < objectArray.length; i++) 				{					if("close" == objectArray[i].getShot) matchingObjects.push(objectArray[i]);				}			}			else 			{				for(var i:int = 0; i < objectArray.length; i++) 				{					if("medium" == objectArray[i].getShot) matchingObjects.push(objectArray[i]);				}			}							//if pool of possibilities is empty			if(matchingObjects.length == 0) 			{				trace("ERROR: no FirstArgument could be found");			}									randNum = Utils.randRound(matchingObjects.length);			//clipNameOfObjectToRemove = matchingObjects[randNum].getClipName;			subjects = contentTagsHash(matchingObjects[randNum]);			metaList.push(matchingObjects[randNum]);			strategy = matchingObjects[randNum].getStrategy;						// remove same clip with different cameraAngle and Clip this clip to prevent being played more than once			Utils.removeWithClipName(objectArray, matchingObjects[randNum].getClipName);			removeShot(bShot, objectArray, matchingObjects[randNum].getClipName);						//for removing element from list so there won't be any duplicates _ Array is being reffrenced _ only primitive Datatypes are call by value _ can also be done in this function			//listOfFilteredObjects = objectArray;						return matchingObjects[randNum];		}					// RETURN FUNCTION 				private function returnToFunction(objectArray:Array, bShot:Boolean):BRDObject		{			var matchingObjects:Array = new Array();						//sort for matching camera shot			if(bShot)			{				for(var i:int = 0; i < objectArray.length; i++) 				{					if(isOnlyAHandAV)					{						if("close" == objectArray[i].getShot && (objectArray[i].getStrategy == "ad rem" || objectArray[i].getStrategy == "ad verecundiam")) matchingObjects.push(objectArray[i]);					}					else					{						if("close" == objectArray[i].getShot && objectArray[i].getStrategy == strategy) matchingObjects.push(objectArray[i]);					}				}			}			else			{				for(var i:int = 0; i < objectArray.length; i++)				{					if(isOnlyAHandAV)					{						if("medium" == objectArray[i].getShot && (objectArray[i].getStrategy == "ad rem" || objectArray[i].getStrategy == "ad verecundiam")) matchingObjects.push(objectArray[i]);					}					else					{						if("medium" == objectArray[i].getShot && objectArray[i].getStrategy == strategy) matchingObjects.push(objectArray[i]);					}				}			}						randNum = Utils.randRound(matchingObjects.length);			metaList.push(matchingObjects[randNum]);			strategy = matchingObjects[randNum].getStrategy;						if(matchingObjects[randNum].getDramaturgy == "return_question") isReactionToQuestion = true;			// remove same clip with different cameraAngle and Clip this clip to prevent being played more than once			Utils.removeWithClipName(objectArray, matchingObjects[randNum].getClipName);			removeShot(bShot, objectArray, matchingObjects[randNum].getClipName);						return matchingObjects[randNum];		}						// REACTION FUNCTION				private function reactionFunction(objectArray:Array, bShot:Boolean):BRDObject		{			var matchingObjects:Array = new Array();						//sort for matching camera shot			if(bShot) 			{				for(var i:int = 0; i < objectArray.length; i++) 				{					if(isReactionToQuestion)					{						if("close" == objectArray[i].getShot && "reaction_to_question" == objectArray[i].getDramaturgy && objectArray[i].getStrategy == strategy) 						{							if(isOnlyAHandAV && isNextStrategyValid(objectArray[i])) matchingObjects.push(objectArray[i]);							else if (!isOnlyAHandAV) matchingObjects.push(objectArray[i]);						}										}					else					{						if("close" == objectArray[i].getShot && "reaction" == objectArray[i].getDramaturgy && objectArray[i].getStrategy == strategy) matchingObjects.push(objectArray[i]);						{							if(isOnlyAHandAV && isNextStrategyValid(objectArray[i])) matchingObjects.push(objectArray[i]);							else if (!isOnlyAHandAV) matchingObjects.push(objectArray[i]);						}					}				}			}			else			{				for(var i:int = 0; i < objectArray.length; i++) 				{					if(isReactionToQuestion)					{						if("medium" == objectArray[i].getShot && "reaction_to_question" == objectArray[i].getDramaturgy && objectArray[i].getStrategy == strategy) matchingObjects.push(objectArray[i]);					}					else					{						if("medium" == objectArray[i].getShot && "reaction" == objectArray[i].getDramaturgy && objectArray[i].getStrategy == strategy) matchingObjects.push(objectArray[i]);					}				}			}					if(matchingObjects.length == 0)			{				trace("ERROR IN REACTION FUNCTION: no matching objectst found");				trace("///////////////////////////////////////////////////////////////////" );				trace("// NOTLÖSUNG DA KEIN ARGUMENT MIT MIN. 1 GLEICHEM THEMA GEFUNDEN //" );				trace("///////////////////////////////////////////////////////////////////" );				matchingObjects = objectArray;			}						isReactionToQuestion = false;			randNum = Utils.randRound(matchingObjects.length);			metaList.push(matchingObjects[randNum]);						//strategy = nextStrategyFunction(matchingObjects[randNum]);			strategy = nextStrategyToString(nextStrategyFunction(matchingObjects[randNum]));						// remove same clip with different cameraAngle and Clip this clip to prevent being played more than once			Utils.removeWithClipName(objectArray, matchingObjects[randNum].getClipName);			removeShot(bShot, objectArray, matchingObjects[randNum].getClipName);									return matchingObjects[randNum];		}						// ARGUMENT FUNCTION				private function argumentFunction(objectArray:Array, bShot:Boolean):BRDObject		{			var matchingObjects:Array = new Array();						//sort for matching camera shot			if(bShot) 			{				for(var i:int = 0; i < objectArray.length; i++) 				{					if("close" == objectArray[i].getShot && objectArray[i].getStrategy == strategy)					{						var tagsCheckSum:int = 0;						var loopHash:Object = contentTagsHash(objectArray[i]); 											//check for same tags						for(var key in loopHash)						{							if(subjects[key] == loopHash[key] && loopHash[key] == "true")							{								checkSum++;							}						}						if(checkSum > 0) matchingObjects.push(objectArray[i]);					}				}			}			else			{				for(var i:int = 0; i < objectArray.length; i++)				{					if("medium" == objectArray[i].getShot && objectArray[i].getStrategy == strategy)					{						var checkSum:int = 0;						var loopHash:Object = contentTagsHash(objectArray[i]); 											//check for same tags						for(var key in loopHash)						{							//trace(key + " : " + loopHash[key] + " : " +  subjects[key]);							if(subjects[key] == loopHash[key] && loopHash[key] == "true")							{								checkSum++;							}						}						if(checkSum > 0) matchingObjects.push(objectArray[i]);					}				}			}						if(0 == matchingObjects.length) 			{				trace("ERROR IN ARGUMENT FUNCTION: no matching objectst found");				trace("///////////////////////////////////////////////////////////////////" );				trace("// NOTLÖSUNG DA KEIN ARGUMENT MIT MIN. 1 GLEICHEM THEMA GEFUNDEN //" );				trace("///////////////////////////////////////////////////////////////////" );				matchingObjects = objectArray;			}						randNum = Utils.randRound(matchingObjects.length);			//clipNameOfObjectToRemove = matchingObjects[randNum].getClipName			metaList.push(matchingObjects[randNum]);			subjects = contentTagsHash(matchingObjects[randNum]);			strategy = matchingObjects[randNum].getStrategy;						// remove same clip with different cameraAngle and Clip this clip to prevent being played more than once			Utils.removeWithClipName(objectArray, matchingObjects[randNum].getClipName);			removeShot(bShot, objectArray, matchingObjects[randNum].getClipName);						//for removing element from list so there won't be any duplicates _ Array is being reffrenced _ only primitive Datatypes are call by value			listOfFilteredObjects = objectArray;						return matchingObjects[randNum];		}						///////////////////////		// HELPING FUNCTIONS //		///////////////////////				private function contentTagsHash(thisObject:BRDObject):Object		{			var hashMap:Object = {				society:thisObject.getCulture,				worldView:thisObject.getWorldView,				culture:thisObject.getCulture,				government:thisObject.getGovernment			}			return hashMap;		}				private function nextStrategyTagsHash(thisObject:BRDObject):Object		{			var hashMap:Object = {				ar:thisObject.getNextAr,				ah:thisObject.getNextAh,				av:thisObject.getNextAv,				sb:thisObject.getNextSb			}			return hashMap;		}						private function nextStrategyFunction(thisObject:BRDObject):Array		{			var newStrategy:String;			var strategyHash:Object = nextStrategyTagsHash(thisObject);			var strategyArray:Array = new Array();						for(var key in strategyHash)			{				if(strategyHash[key] == "true")				{					switch(key)					{						case "ar":						strategyArray.push("ad rem");						break;						case "av":						strategyArray.push("ad verecundiam");						break;						case "ah":						strategyArray.push("ad hominem");						break;						case "sb":						strategyArray.push("shifting burden");						break;											}				}			}						return strategyArray		}						private function nextStrategyToString(thisArray:Array):String		{			var newStrategy:String = thisArray[Utils.randRound(thisArray.length)];			return newStrategy;		}				// Even though there might be cases where there are 2 tags and only 1 fits the rules and the other one is shown in Debug Mode this Function implements the Rule 100%		private function isNextStrategyValid(thisObject:BRDObject):Boolean		{			var strategyArrayToCheck:Array = nextStrategyFunction(thisObject);			for(var i:int = 0; i< strategyArrayToCheck.length; i++)			{				if("ad rem" == strategyArrayToCheck[i] || "ad verecundiam" == strategyArrayToCheck[i]) 				return true;			}			return false;		}						private function removeShot(bIsClose:Boolean, fromArray:Array, elementName:String):void		{			// remove shot that is close			if(!bIsClose)			{				for(var i:int; i < fromArray.length; i++)				{					//trace("Element HN: " + elementName.substring(0,elementName.length - 6));					if(elementName.substring(0,elementName.length - 6) === fromArray[i].getClipName.substring(0,fromArray[i].getClipName.length - 5))					{						//trace("Element with Close Shot removed: " + fromArray[i].getClipName);						fromArray.splice(i,1);					}				}				//if(-1 != elementName.search("N")) 			}			else			{				for(var i:int; i < fromArray.length; i++)				{					//trace("Element N: " + elementName.substring(0,elementName.length - 5));					if(elementName.substring(0,elementName.length - 5) === fromArray[i].getClipName.substring(0,fromArray[i].getClipName.length - 6))					{						//trace("Element with Medium Shot removed: " + fromArray[i].getClipName);						fromArray.splice(i,1);					}				}			}		}	}}