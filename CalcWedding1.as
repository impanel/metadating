////////////////*TO DO:- [SOLVED] Kamerawechsel- [SOLVED] Delete same but different shot- Intro Outro Regeln implementieren (waiting for Intros and Outros)- flowing reaction einbauen*////////////////package  {		import flash.events.*;	import flash.display.*;	import flash.utils.Dictionary;	import Player;	import Wedding1Object;	import Utils;	import fl.controls.progressBarClasses.IndeterminateBar;				public class CalcWedding1 {		public function CalcWedding1() {			// constructor code		}				/////////////		//VARIABLES//		/////////////		//Intro		private var intro:Array;		//Outro		private var outro:Array;		// Arrays		private var manProR:Array;		private var manProA:Array;		private var womanProR:Array;		private var womanProA:Array;		private var manContraR:Array;		private var manContraA:Array;		private var womanContraR:Array;		private var womanContraA:Array;								//MOST IMPORTANT		private var randNum:int;				/////////////////////		//Helping variables//		/////////////////////				//BOOLEANS		private var isMan:Boolean;		private var isPro:Boolean;		private var manProAndWomanContra:Boolean;		private var isSteadyCam:Boolean;		private var skipCamToggle:Boolean;		private var skipAction:Boolean;				//STRINGS		private var strategyReaction:String;		private var strategyAction:String;		private var strategyCurrent:String;				private var clipNameOfObjectToRemove:String;				//ARRAYS		private var listOfFilteredObjects:Array;		public var metaList:Array;		private var tagList:Array;				//NUMBERS		private var intensityReaction:int;		private var intensityAction:int;		private var intensityCurrent:int;				//OBJECTS		private var tagsAction:Object;		private var tagsReaction:Object;		private var tagsCurrent:Object;				private var playList: Array;		private var videoObjects: Array;				public function calculateClips(xml:XMLList): Array 		{			playList = new Array();			metaList = new Array();			videoObjects = new Array();						intro = new Array();			outro = new Array();						manProR = new Array();			womanProR = new Array();			manContraR = new Array();			womanContraR = new Array();			manProA = new Array();			womanProA = new Array();			manContraA = new Array();			womanContraA = new Array();						Utils.allFilesNames = new Array();			listOfFilteredObjects = new Array();			metaList = new Array();			tagList = new Array();						tagsAction = new Object();			tagsReaction = new Object();			tagsCurrent = new Object();						skipAction = false;						//isSteadyCam = false;						////////////////////////			//MAIN PUBLIC FUNCTION//			////////////////////////						//FILTERING			for (var i:int = 0; i<xml.length(); i++)			{				videoObjects[i] = new Wedding1Object (i,													  xml[i].clipname.text(),													  xml[i].pro_contra.text(),													  xml[i].reaction_action.text(),													  xml[i].male_female.text(),													  xml[i].strategy.text(),													  xml[i].intensity.text(),													  xml[i].shot.text(),													  xml[i].clip_pos.text(),													  xml[i].family.text(),													  xml[i].religion.text(),													  xml[i].emotion.text(),													  xml[i].society.text(),													  xml[i].routine.text(),													  xml[i].spare_time.text(),													  xml[i].safety.text(),													  xml[i].freedom.text(),													  xml[i].loyalty_sex.text(),													  xml[i].emotional_reaction.text(),													  xml[i].flowing_reaction.text(),													  xml[i].joker.text()												 		);								Utils.allFilesNames.push(videoObjects[i].getClipName);								//filter intro				// No intro there yet				if(videoObjects[i].getClipPos == "intro") intro.push(videoObjects[i]);				//filter outro				if(videoObjects[i].getClipPos == "outro") outro.push(videoObjects[i]);								if(videoObjects[i].getMaleFemale == "male" && videoObjects[i].getClipPos != "outro" && videoObjects[i].getClipPos != "intro")				{					if(videoObjects[i].getProContra == "pro") 					{						if(videoObjects[i].getReactionAction == "reaction") manProR.push(videoObjects[i]);						else manProA.push(videoObjects[i]);					}										else					{						if(videoObjects[i].getReactionAction == "action") manContraA.push(videoObjects[i]);						else manContraR.push(videoObjects[i]);					}				}								if(videoObjects[i].getMaleFemale == "female" && videoObjects[i].getClipPos != "outro" && videoObjects[i].getClipPos != "intro")				{					if(videoObjects[i].getProContra == "pro") 					{						if(videoObjects[i].getReactionAction == "reaction") womanProR.push(videoObjects[i]);						else womanProA.push(videoObjects[i]);					}										else					{						if(videoObjects[i].getReactionAction == "action") womanContraA.push(videoObjects[i]);						else womanContraR.push(videoObjects[i]);					}				}			}									//ASSEMBLING PLAYLIST////////////////////////////////////////////////////////////////////////////////									//determine which camera Shot starts			isSteadyCam = Utils.randRound(2);			// value for changing camera angle when speakers change			//skipCamToggle = Utils.randRound(2);						//intro			if(intro.length != 0)			{				randNum = Utils.randRound(intro.length);				playList.push(intro[randNum].getClipName);				metaList.push(intro[randNum]);			}						//determine who begins			isMan = Utils.randRound(2);			//determine standpoint			isPro = Utils.randRound(2);						playList.push(firstReaction().getClipName);			//Utils.remove(listOfFilteredObjects, randNum);						for(var i:int = 0; i < 15; i++)			{				//trace("-----------------------------");				if(!skipAction)				{					skipCamToggle = Utils.randRound(2);					playList.push(argument().getClipName);				}				else isMan ? isMan = false : isMan = true; // since argument function is skipped because of flowing_Reaction we have to manually toggle isMan value								//trace("Clip Argument: " + playList[playList.length - 1]);				playList.push(reaction().getClipName)				//trace("Clip Reaction: " + playList[playList.length - 1]);			}						//var testHash:Object = contentTagsHash(firstArgument());						//OUTRO			if(outro.length != 0) 			{				randNum = Utils.randRound(outro.length);				playList.push(outro[randNum].getClipName);				metaList.push(outro[randNum]);			}						//////////////////////////////////////////////////////////////////////////////////////////////////////			Utils.checkForDuplicates(playList);			return playList;		}								//////////////////		//MAIN FUNCTIONS//		//////////////////				/*		//INTRO		private function introClip():Wedding1Object		{			//waiting for intros		}				//OUTRO		private function outroClip():Wedding1Object		{			//waiting for outros					}		*/				//1st REACTION		private function firstReaction():Wedding1Object 		{			//trace("---first reaction---");						if(isMan)			{				//isMan = false;				if(isPro)				{					manProAndWomanContra = true;					//trace("MAN IS PRO");					return firstReactionFunction(manProR);				}				else				{					manProAndWomanContra = false;					//trace("MAN IS CONTRA");					return firstReactionFunction(manContraR);				}			}			else			{				//isMan = true;				if(isPro)				{					manProAndWomanContra = false;					//trace("WOMAN IS PRO");					return firstReactionFunction(womanProR);				}				else				{					manProAndWomanContra = true;					//trace("WOMAN IS CONTRA");					return firstReactionFunction(womanContraR);				}			}			trace("ERROR in first Argument Function");			//waiting for intros		}						//REACTION		private function reaction():Wedding1Object		{			//trace("---reaction---");						if(isMan)			{				if(manProAndWomanContra)				{					return reactionFunction(manProR);				}				else				{					return reactionFunction(manContraR);				}			}			else			{				if(!manProAndWomanContra)				{					return reactionFunction(womanProR);				}				else				{					return reactionFunction(womanContraR);					}			}			trace("ERROR in reaction function");		}						//ARGUMENT		private function argument():Wedding1Object		{			//trace("---argument---");						if(isMan)			{				isMan = false;				if(manProAndWomanContra)				{					return actionFunction(manProA);				}				else				{					return actionFunction(manContraA);				}			}			else			{				isMan = true;				if(!manProAndWomanContra)				{					return actionFunction(womanProA);				}				else				{					return actionFunction(womanContraA);				}			}			trace("ERROR in first Argument Function");		}								/////////////		//THE HEART//		/////////////				/*		private function introFunction(objectArray):Wedding1Object		{			//waiting for Intros		}				private function outroFunction(objectArray):Wedding1Object		{			//waiting for Outros		}		*/						private function firstReactionFunction(objectArray):Wedding1Object		{			var matchingObjects:Array = new Array();						if(!isSteadyCam)			{				for(var i:int = 0; i < objectArray.length; i++)				{					if("steady" == objectArray[i].getShot && 1 == objectArray[i].getIntensity) matchingObjects.push(objectArray[i]);				}			}			else			{				for(var i:int = 0; i < objectArray.length; i++)				{					if("totale" == objectArray[i].getShot && 1 == objectArray[i].getIntensity) matchingObjects.push(objectArray[i]);				}			}						randNum = Utils.randRound(matchingObjects.length);			strategyReaction = matchingObjects[randNum].getStrategy;			intensityAction = matchingObjects[randNum].getIntensity;			//this are the tags for the next reaction			tagsReaction = contentTagsHash(matchingObjects[randNum]);			//push Object in metaList for Debug			metaList.push(objectArray[randNum]);			//trace("1. Strategy: " + matchingObjects[randNum].getStrategy);			//Remove this Clips from Array(Arrays are refferenced in AS3) so there won't be duplicates			Utils.removeWithClipName(objectArray, matchingObjects[randNum].getClipName);			//Remove Clips with same content but different shot			removeShot(isSteadyCam, objectArray, matchingObjects[randNum].getClipName);			//toggle isSteadyCam so next Shot is different						toggleIsSteadyCam();						if(matchingObjects[randNum].getFlowingReaction == "true") skipAction = true;						return matchingObjects[randNum];						//still waiting for Intros !		}								//REAKTION		private function reactionFunction(objectArray:Array):Wedding1Object		{			skipAction = false;			var selectedArray:Array = new Array();			var counter:uint = 0;			//trace("strategyReaction: " + strategyReaction);			//trace("intensityReaction: " + intensityReaction);						//1. RULE (a)			if(strategyReaction == "ad rem")			{				//trace("ad rem loop");				selectedArray = listOfMatchingReactionsIntensity(filteredShotArray(isSteadyCam, objectArray), intensityReaction, 1);				randNum = Utils.randRound(selectedArray.length);			}						//2. RULE (b)			else if(strategyReaction == "ad verecundiam")			{				//trace("ad verecundiam loop");				selectedArray = listOfMatchingReactionsIntensity(filteredShotArray(isSteadyCam, objectArray), intensityReaction, 2);				randNum = Utils.randRound(selectedArray.length);			}						//3. RULE (c)			else			{				//trace("rest loop");				selectedArray = listOfMatchingReactionsIntensity(filteredShotArray(isSteadyCam, objectArray), intensityReaction, 3);				randNum = Utils.randRound(selectedArray.length);			}						//Strategy to be checked in actionFunction			strategyAction = selectedArray[randNum].getStrategy;									metaList.push(selectedArray[randNum]);			//Remove this Clips from Array(Arrays are refferenced in AS3) so there won't be duplicates			Utils.removeWithClipName(objectArray, selectedArray[randNum].getClipName);			//Remove Clips with same content but different shot			removeShot(isSteadyCam, objectArray, selectedArray[randNum].getClipName);						//toggle isSteadyCam so next Shot is different			toggleIsSteadyCam();						if(selectedArray[randNum].getFlowingReaction == "true") skipAction = true;						return selectedArray[randNum];		}												//ARGUMENT		private function actionFunction(objectArray:Array):Wedding1Object		{			//call important function			var selectedArray:Array = listOfMatchingActions(filteredShotArray(isSteadyCam, objectArray),strategyAction, tagsAction);			randNum = Utils.randRound(selectedArray.length);						//randNum = Utils.randRound(objectArray.length);						//set for reaction			strategyReaction = selectedArray[randNum].getStrategy;			intensityReaction = selectedArray[randNum].getIntensity;									//trace(selectedArray[randNum].getStrategy);			tagsAction = contentTagsHash(selectedArray[randNum]);			metaList.push(selectedArray[randNum]);			//Remove this Clips from Array(Arrays are refferenced in AS3) so there won't be duplicates			Utils.removeWithClipName(objectArray, selectedArray[randNum].getClipName);			//Remove Clips with same content but different shot			removeShot(isSteadyCam, objectArray, selectedArray[randNum].getClipName);			//toggle isSteadyCam so next Shot is different			if(!skipCamToggle) toggleIsSteadyCam();						return selectedArray[randNum];		}						/////////////////////		//HELPING FUNCTIONS//		/////////////////////				private function contentTags(thisObject:Wedding1Object):Array		{			var returnArr:Array = new Array();			returnArr.push(thisObject.getFamily);			returnArr.push(thisObject.getReligion);			returnArr.push(thisObject.getEmotion);			returnArr.push(thisObject.getSociety);			returnArr.push(thisObject.getRoutine);			returnArr.push(thisObject.getSpareTime);			returnArr.push(thisObject.getSafety);			returnArr.push(thisObject.getFreedom);			returnArr.push(thisObject.getLoyaltySex);						//trace(returnArr);			return returnArr;		}				private function contentTagsHash(thisObject:Wedding1Object):Object		{			var hashMap:Object = {				family:thisObject.getFamily,				religion:thisObject.getReligion,				emotion:thisObject.getEmotion,				society:thisObject.getSociety,				routine:thisObject.getRoutine,				spareTime:thisObject.getSpareTime,				safety:thisObject.getSafety,				freedom:thisObject.getFreedom,				loyaltySex:thisObject.getLoyaltySex			}						/*			var testHash:Object = hashMap;			for(var key:Object in testHash) trace(key + " : " + testHash[key]);			if(testHash == hashMap)trace("HASH MAP IS SAME");			else trace("NOPE");			*/			return hashMap;		}				/*		LIST OF MATCHING OBJECTS FOR REACTION 		*/				private function listOfMatchingReactionsIntensity(listOfAllObjects:Array, intensity:int, rule:int):Array		{			var matchingObjects:Array = new Array();			switch(rule)			{				//1.RULE (a)				case 1 :					for(var i:int = 0; i < listOfAllObjects.length; i++)					{						if(intensity == listOfAllObjects[i].getIntensity)						{							matchingObjects.push(listOfAllObjects[i]);						}					}										if(matchingObjects.length == 0) // if nothing found then look for intenstiy-- or intensity++					{						for(var i:int = 0; i < listOfAllObjects.length; i++)						{							if(intensity == listOfAllObjects[i].getIntensity - 1 || intensity == listOfAllObjects[i].getIntensity - 1)							{								matchingObjects.push(listOfAllObjects[i]);							}						}					}										if(matchingObjects.length == 0) // still none found then look for object with emotional reaction					{						for(var i:int = 0; i < listOfAllObjects.length; i++)						{							if(listOfAllObjects[i].getEmotionalReaction == "true")							{								matchingObjects.push(listOfAllObjects[i]);							}						}					}				break;				//2.RULE (b)				case 2 :					for(var i:int = 0; i < listOfAllObjects.length; i++)					{						if(intensity == listOfAllObjects[i].getIntensity || intensity == listOfAllObjects[i].getIntensity + 1 || intensity == listOfAllObjects[i].getIntensity - 1)						{							matchingObjects.push(listOfAllObjects[i]);						}					}										if(matchingObjects.length == 0) // still none found then look for object with emotional reaction					{						for(var i:int = 0; i < listOfAllObjects.length; i++)						{							if(listOfAllObjects[i].getEmotionalReaction == "true")							{								matchingObjects.push(listOfAllObjects[i]);							}						}					}				break;				//3.RULE (c)				case 3 :					for(var i:int = 0; i < listOfAllObjects.length; i++)					{						if(intensity == listOfAllObjects[i].getIntensity || intensity == listOfAllObjects[i].getIntensity + 1)						{							matchingObjects.push(listOfAllObjects[i]);						}					}										if(matchingObjects.length == 0) // still none found then look for object with emotional reaction					{						for(var i:int = 0; i < listOfAllObjects.length; i++)						{							if(listOfAllObjects[i].getEmotionalReaction == "true")							{								matchingObjects.push(listOfAllObjects[i]);							}						}					}				break;								default:					trace("ERROR: there are only 3 rules defined");				break;			}						if(matchingObjects.length == 0)			{				trace("ERROR: FITTING REACTION(INTENSITY) COULDN'T BE FOUND");				trace("//////////////////////////////");				trace("/// NOTLÖSUNG FÜR REAKTION ///");				trace("//////////////////////////////");				return listOfAllObjects;			}			/*			NEW RULES			*/			if(matchingObjects.length != 0)			{				var finalObjects:Array = listOfMatchingReactions(matchingObjects, strategyReaction, tagsAction);				trace("ELEMENTS IN FINAL OBJECTS FOR REACTION: " + finalObjects.length);				//				// wenn keine Clips in listOfMatchingReactions gefunden wurden nehme die gröbere Filterung matchingObjects (NOTLÖSUNG DA DIE STRATEGIE DER STUDENTEN NICHT AUFGEHT)				if(0 == finalObjects.length)				{					return matchingObjects;				}			}			return finalObjects; 		}				private function listOfMatchingReactions(listOfAllObjects:Array, strategy:String, tagsHash:Object):Array		{			var matchingObjects:Array = new Array();						//check how many primary and secondary tags are in the hashMap			var numPrimTags:int = 0;			var numSecTags:int = 0;						var whichRule:int = 0;						for(var key in tagsHash)			{				if(tagsHash[key] == 1) numPrimTags++;				else if(tagsHash[key] == 2) numSecTags++;				//trace(key + " : " + tagsHash[key]);			}			//trace("PrimTags: " + numPrimTags + " : SecTags: " + numSecTags);						//--------------------------------------------------------------------THE RULES----------------------------------------------------------						//1.RULE			// iterate through all objects and look for matching strategy			for(var i:int = 0; i < listOfAllObjects.length; i++)			{				//listOfAllObjects[i].				// check for same strategy and 100% matching tags (check tags is only called if same strategy is found) but no Jokers(when implemented ERROR)				//if(strategy == listOfAllObjects[i].getStrategy && listOfAllObjects[i].getJoker == false)				if(strategy == listOfAllObjects[i].getStrategy)				{										//trace("ARGUMENT WITH SAME STRATEGY");					//					var tagsCheckSum:int = 0;					var loopHash:Object = contentTagsHash(listOfAllObjects[i]); 										//check for same tags					for(var key in loopHash)					{						if(tagsHash[key] == loopHash[key])						{							tagsCheckSum++;						}					}										// if they have the same Tags (9/9)					if(tagsCheckSum == 9) 					{						whichRule = 1;						matchingObjects.push(listOfAllObjects[i]);					}				}			}						//2. RULE			//if no matching objects where found check for 100% matching tags			if(matchingObjects.length == 0) // then only check for 100% matching tags			{				whichRule = 2;												for(var i:int = 0; i < listOfAllObjects.length; i++)				{					var tagsCheckSum:int = 0;					var loopHash:Object = contentTagsHash(listOfAllObjects[i]); 										//check for same tags					for(var key in loopHash)					{						if(tagsHash[key] == loopHash[key])						{							tagsCheckSum++;						}					}										// if they have the same Tags (9/9) and are not a Joker					//if(tagsCheckSum == 9 && listOfAllObjects[i].getJoker == false) matchingObjects.push(listOfAllObjects[i]);					if(tagsCheckSum == 9) matchingObjects.push(listOfAllObjects[i]);				}			}						//3.RULE			if(matchingObjects.length == 0) // still nothing, then check for matching primary tags and at least 1 sec. tag			{				whichRule = 3;											for(var i:int = 0; i < listOfAllObjects.length; i++)				{					var tagsCheckSum:int = 0;					var primTagsCheckSum:int = 0;					var secTagsCheckSum:int = 0;					var loopHash:Object = contentTagsHash(listOfAllObjects[i]); 										for(var key in loopHash)					{						if(tagsHash[key] == loopHash[key] && 1 == loopHash[key])						{							primTagsCheckSum++;						}						else if(tagsHash[key] == loopHash[key] && 2 == loopHash[key])						{							secTagsCheckSum++;						}					}										//if(primTagsCheckSum == numPrimTags && secTagsCheckSum > 0 && listOfAllObjects[i].getJoker == false) matchingObjects.push(listOfAllObjects[i]);					if(primTagsCheckSum == numPrimTags && secTagsCheckSum > 0) matchingObjects.push(listOfAllObjects[i]);				}			}						//4.RULE			if(matchingObjects.length == 0) // still nothing, then check for matching strategy and at least 1 prim. tag			{				whichRule = 4;								for(var i:int = 0; i < listOfAllObjects.length; i++)				{						if(strategy == listOfAllObjects[i].getStrategy)					{												//trace("ARGUMENT WITH SAME STRATEGY");						//						//var tagsCheckSum:int = 0;						var primTagsCheckSum:int = 0;						var loopHash:Object = contentTagsHash(listOfAllObjects[i]); 												//check for same tags						for(var key in loopHash)						{							if(tagsHash[key] == loopHash[key] && 1 == loopHash[key])							{								primTagsCheckSum++;							}						}												// if they have the at least one matching primary tag						if(primTagsCheckSum > 0) matchingObjects.push(listOfAllObjects[i]);					}				}			}						//5.RULE			if(matchingObjects.length == 0) // still nothing, then check for at least 1 primary tags			{				whichRule = 5;								for(var i:int = 0; i < listOfAllObjects.length; i++)				{					var tagsCheckSum:int = 0;					var primTagsCheckSum:int = 0;					var loopHash:Object = contentTagsHash(listOfAllObjects[i]); 										for(var key in loopHash)						{							if(tagsHash[key] == loopHash[key] && 1 == loopHash[key])							{								primTagsCheckSum++;							}						}												// if they have the at least one matching primary tag						if(primTagsCheckSum > 0) matchingObjects.push(listOfAllObjects[i]);				}			}						//6.RULE			if(matchingObjects.length == 0) // still nothing, then check for at least 1 secondary tags			{				whichRule = 6;								for(var i:int = 0; i < listOfAllObjects.length; i++)				{					var tagsCheckSum:int = 0;					var secTagsCheckSum:int = 0;					var loopHash:Object = contentTagsHash(listOfAllObjects[i]); 										for(var key in loopHash)						{							if(tagsHash[key] == loopHash[key] && 2 == loopHash[key])							{								secTagsCheckSum++;							}						}												// if they have the at least one matching secondary tag						if(secTagsCheckSum > 0) matchingObjects.push(listOfAllObjects[i]);				}			}						//7.RULE			if(matchingObjects.length == 0) // still nothing, then check for matching strategy			{				whichRule = 7;								for(var i:int = 0; i < listOfAllObjects.length; i++)				{					if(strategy == listOfAllObjects[i].getStrategy)					{						matchingObjects.push(listOfAllObjects[i]);					}				}			}						if(matchingObjects.length == 0 || whichRule == 0)			{				trace("JOKER: NO RULE FOR REACTION COULD BE APLLIED");				for(var i:int = 0; i < listOfAllObjects.length; i++)				{					if(listOfAllObjects[i].getJoker == true) matchingObjects.push(listOfAllObjects[i]);				}				trace("JOKERS IN POOL: " + matchingObjects.length);			}			trace("REACTION " + whichRule + ". RULE");						return matchingObjects;		}				/*		LIST OF MATCHING ACTIONS 		*/		//filteredShotArray(isSteadyCam, objectArray),strategyAction, tagsAction		private function listOfMatchingActions(objectArray:Array, strategy:String, tags:Object):Array		{			var matchingObjects:Array = new Array();						// Rule 1: is there an Action where all 2 tags are matching 			for(var i:int = 0; i < objectArray.length; i++)			{				var primTagsCheckSum:int = 0;				var loopHash:Object = contentTagsHash(objectArray[i]); 										//check for same tags				for(var key in loopHash)				{					if(tags[key] == loopHash[key])					{						primTagsCheckSum++;					}				}								// if all tags are matching				if(primTagsCheckSum == 9) matchingObjects.push(objectArray[i]);			}						// Rule 2			if(matchingObjects.length == 0)			{				for(var i:int = 0; i < objectArray.length; i++)				{					var primTagsCheckSum:int = 0;					var loopHash:Object = contentTagsHash(objectArray[i]); 												//check for same tags					for(var key in loopHash)					{						if(tags[key] == loopHash[key] && (1 == loopHash[key] || 2 == loopHash[key]) )						{							primTagsCheckSum++;						}					}										// if at least 1 tag is matching (primary or secondary)					if(primTagsCheckSum > 0) matchingObjects.push(objectArray[i]);				}			}						if(matchingObjects.length == 0)			{				for(var i:int = 0; i < objectArray.length; i++)				{					if(objectArray[i].getJoker == "true") matchingObjects.push(objectArray[i]);				}			}			if(matchingObjects.length == 0)			{				trace("ERROR: NO MATCHING ACTIONS COULD BE FOUND");				trace("///////////////////////////");				trace("/// NOTLÖSUNG FÜR AKTION///");				trace("///////////////////////////");				return objectArray;			}						return matchingObjects;		}				//-----------------------------------------------------------------------------------------------------				// filter proper camera shot				private function filteredShotArray(isSteady:Boolean, objectArray:Array):Array		{			var matchingObjects:Array = new Array();						if(isSteady)			{				for(var i:int = 0; i < objectArray.length; i++)				{					if("totale" == objectArray[i].getShot)					{						matchingObjects.push(objectArray[i]);					}				}			}			else			{				for(var i:int = 0; i < objectArray.length; i++)				{					if("steady" == objectArray[i].getShot)					{						matchingObjects.push(objectArray[i]);					}				}			}						return matchingObjects;		}				// remove clips with same content but different camera angle				private function removeShot(isSteady:Boolean, fromArray:Array, elementName:String):void		{			// remove shot that is close			if(!isSteady)			{				for(var i:int; i < fromArray.length; i++)				{					//trace("Element HN: " + elementName.substring(0,elementName.length - 6));					if(elementName.substring(0,elementName.length - 5) === fromArray[i].getClipName.substring(0,fromArray[i].getClipName.length - 5))					{						//trace("Element with Steady Shot removed: " + fromArray[i].getClipName);						fromArray.splice(i,1);					}				}				//if(-1 != elementName.search("N")) 			}			else			{				for(var i:int; i < fromArray.length; i++)				{					//trace("Element N: " + elementName.substring(0,elementName.length - 5));					if(elementName.substring(0,elementName.length - 5) === fromArray[i].getClipName.substring(0,fromArray[i].getClipName.length - 5))					{						//trace("Element with Totale Shot removed: " + fromArray[i].getClipName);						fromArray.splice(i,1);					}				}			}		}				private function toggleIsSteadyCam():void		{			isSteadyCam?isSteadyCam = false : isSteadyCam = true;		}//-----------------------------END--------------------------------------------	}}