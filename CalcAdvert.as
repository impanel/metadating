package  {		public class CalcAdvert {				import flash.events.*;		import flash.display.*;		import flash.utils.Dictionary;		import Player;		import AdvertObject;		import Utils;		public function CalcAdvert() {			// constructor code		}				//--------------------------------------		//  PRIVATE VARIABLES		//--------------------------------------		private var playList: Array;		private var videoObjects: Array;		public var speechList:Array;		public var musicList:Array;				//Arrays		private var video:Array;		private var music:Array;		private var speech:Array;		private var error:Array;		private var usedGroup:Array;		private var videoClips:Array;		private var speechClips:Array;		private var musicClip:Array;				// save Objects for Debug Display		public var metaList: Array;				//Funktionsvariablen		private var randNum:uint;		//private var randNumVid:uint;		//private var randNumMusic:uint;		//private var randNumSpeech:uint;		private var sortedArray:Array;		private var temporarySelection:Array;		private var finalSelection:Array;		//--------------------------------------		//  PUBLIC METHODS		//--------------------------------------		public function calculateClips(xml:XMLList): Array 		{			playList = new Array ();			videoObjects = new Array ();			video = new Array();			music = new Array();			speech = new Array();			error = new Array();			speechList = new Array();			musicList = new Array();			usedGroup = new Array();			videoClips = new Array();			speechClips = new Array();			musicClip = new Array();			metaList = new Array();						trace("calculating");						for (var i:int = 0; i<xml.length(); i++)			{				videoObjects[i] = new AdvertObject (													i, 																		//xml[i].file.text(),															xml[i].user_id.text(),													xml[i].clipname.text(),														xml[i].trust.text(),																										xml[i].pride.text(),													xml[i].success.text(),													xml[i].passion.text(),													xml[i].surprise.text(),													xml[i].fear.text(),													xml[i].media.text(),													xml[i].beginning.text(),													xml[i].middle.text(),													xml[i].fin.text()																);								if(videoObjects[i].media == "video") video.push(videoObjects[i]);								else if(videoObjects[i].media == "speech") speech.push(videoObjects[i]);								else if(videoObjects[i].media == "music") music.push(videoObjects[i]);												else error.push(videoObjects[i]);							}						trace("VIDEOS: " + video.length);			trace("SPEECH: " + speech.length);			trace("MUSIC: " + music.length);						// DEFINE 3 VIDEOCLIPS			videoClips[0] = makeFinalSelection(sortMedia("beginning", video), Utils.feeling, Utils.definitude);			usedGroup[0] = videoClips[0].getClipName;			metaList[0] = videoClips[0];			videoClips[1] = makeFinalSelection(sortMedia("middle", video), Utils.feeling, Utils.definitude);			usedGroup[1] = videoClips[1].getClipName;			metaList[1] = videoClips[1];			videoClips[2] = makeFinalSelection(sortMedia("fin", video), Utils.feeling, Utils.definitude);			metaList[2] = videoClips[2];			for(var i:int = 0; i < videoClips.length; i++)			{				if(videoClips[i] != null)				playList.push(videoClips[i].getClipName);			}						usedGroup = new Array();						//DEFINE 3 UNDERLYING SPEECHCLIPS			speechClips[0] = makeFinalSelection(sortMedia("beginning", speech), Utils.feeling, Utils.definitude);			usedGroup[0] = speechClips[0].getClipName;			metaList[3] = speechClips[0];			speechClips[1] = makeFinalSelection(sortMedia("middle", speech), Utils.feeling, Utils.definitude);			usedGroup[1] = speechClips[1].getClipName;			metaList[4] = speechClips[1];			speechClips[2] = makeFinalSelection(sortMedia("fin", speech), Utils.feeling, Utils.definitude);			metaList[5] = speechClips[2];			for(var i:int = 0; i < speechClips.length; i++)			{				if(speechClips[i] != null)				speechList.push(speechClips[i].getClipName);			}						//DEFINE 1 UNDERLYING MUSICCLIP			musicList.push(makeFinalSelection(sortMedia("beginning", music), Utils.feeling, Utils.definitude).getClipName);						trace("VIDEOLIST: " + playList);			return playList;		}						private function sortMedia(clipPosition:String, arrayToSort:Array):Array		{			sortedArray = new Array();			switch(arrayToSort[0].getMedia)			{				case "video":					trace("------- sorting videos " + clipPosition + " --------");				break;				case "speech":					trace("------- sorting speech " + clipPosition + " --------");				break;				case "music":					trace("------- sorting music " + clipPosition + " --------");				break;			}						trace("Array Size: " + arrayToSort.length + "  Position: " + clipPosition);							for(var i:int = 0; i < arrayToSort.length; i++)			{				if(clipPosition == "beginning")				{					if(arrayToSort[i].getBeginning == "true")					{						sortedArray.push(arrayToSort[i]);						//Utils.remove(arrayToSort, i); // remove this element so it won't be repeated in the playList/speechList/musicList					}				}				else if(clipPosition == "middle")				{					if(arrayToSort[i].getMiddle == "true")					{						sortedArray.push(arrayToSort[i]);						//Utils.remove(arrayToSort, i); // remove this element so it won't be repeated in the playList/speechList/musicList					}				}				else if(clipPosition == "fin")				{					if(arrayToSort[i].getFin == "true")					{						sortedArray.push(arrayToSort[i]);						//Utils.remove(arrayToSort, i); // remove this element so it won't be repeated in the playList/speechList/musicList					}				}			}						trace("Sorted Array Size: " + sortedArray.length);			return sortedArray;		}						private function makeTemporarySelection(arrayToSelectFrom:Array, feeling:String, definitude:uint):Array		{			temporarySelection = new Array();						switch(feeling)			{				case "trust":					for(var i:int = 0; i < arrayToSelectFrom.length; i++)					{						if(arrayToSelectFrom[i].getTrust >= definitude) temporarySelection.push(arrayToSelectFrom[i]);					}				break;				case "pride":					for(var i:int = 0; i < arrayToSelectFrom.length; i++)					{						if(arrayToSelectFrom[i].getPride >= definitude) temporarySelection.push(arrayToSelectFrom[i]);					}				break;				case "success":					for(var i:int = 0; i < arrayToSelectFrom.length; i++)					{						if(arrayToSelectFrom[i].getSuccess >= definitude) temporarySelection.push(arrayToSelectFrom[i]);					}				break;				case "passion":					for(var i:int = 0; i < arrayToSelectFrom.length; i++)					{						if(arrayToSelectFrom[i].getPassion >= definitude) temporarySelection.push(arrayToSelectFrom[i]);					}				break;				case "surprise":					for(var i:int = 0; i < arrayToSelectFrom.length; i++)					{						if(arrayToSelectFrom[i].getSurprise >= definitude) temporarySelection.push(arrayToSelectFrom[i]);					}				break;				case "fear":					for(var i:int = 0; i < arrayToSelectFrom.length; i++)					{						if(arrayToSelectFrom[i].getFear >= definitude) temporarySelection.push(arrayToSelectFrom[i]);					}				break;			}									trace("TEMPORARY SELECTION: " + temporarySelection.length);			return temporarySelection;		}						private function makeFinalSelection(arrayToSelectFrom:Array, feeling:String, definitude:uint):AdvertObject		{			finalSelection = new Array();			var checkSum:uint;			var thisDefinitude = definitude; 						do			{				finalSelection = makeTemporarySelection(arrayToSelectFrom, feeling, thisDefinitude);				//trace("DEFINITUDE: " + definitude);				checkSum = finalSelection.length;				if(Utils.definitude > 0 && checkSum == 0)				{					thisDefinitude--;					trace("definitude set to: " + thisDefinitude + " because the selection Array was 0.");				}				//else Utils.definitude++;// ??? geht das und wird dann der vorhergehenden Funktion übergeben			}			while(checkSum == 0);			//removeVersions(finalSelection);			finalSelection = removeVersions(finalSelection);			randNum = Utils.randRound(finalSelection.length)						return finalSelection[randNum];						//return finalSelection;		}				private function pickClip(arrayToPickFrom:Array):AdvertObject		{			randNum = Utils.randRound(arrayToPickFrom.length)			return arrayToPickFrom[randNum];		}						////////////////////		// REMOVE DOUBLES //		////////////////////				private function removeVersions(arr:Array):Array		{			var allVersions:Array = new Array();			var allVersionsSorted:Array = new Array();			var k:uint = 0;			allVersionsSorted[k] = new Array();						//var arr:Array = ["a0", "k5", "a1","b1","b2","c1","b3","d1","c2", "d2", "e1", "d3", "a8", "d4", "d5", "a7"];			//var arr:Array = ["a6", "b6"];			//var usedArr:Array = ["b6","a6"];			/*var array:Array = ["wer"];			array.splice(0, 1);			var array2:Array = ["wertz"];			array2.push(array[0]);			trace(array2);*/						arr.sortOn("getClipName", Array.DESCENDING);			usedGroup.sort(Array.DESCENDING);						//look for clip that was used before and remove all others of this group						if(usedGroup.length > 0)			{				trace("-- used Group: " + usedGroup.length + " : " + usedGroup);				for (var i:int = 0; i < arr.length; i++)				{					trace("before: " + arr[i].getClipName); 				}												for(var i:int = 0; i < arr.length; i++)				{					for(var j:int = 0; j < usedGroup.length; j++)					{							if(arr.length > 0 && i != -1)						{							//trace("i before = " + i);							if(arr[i].getClipName.substring(0,7) === usedGroup[j].substring(0,7))							{								trace("-- Doppelte Gefunden: " + arr[i].getClipName);								arr.splice(i, 1);								trace("-- entfernt");								if(i >= 0)i--;								//trace("i = " + i);							}						}					}				}			}						for (var i:int = 0; i < arr.length; i++)			{				trace("after: " + arr[i].getClipName); 			}						return arr;															//TEST FUNCTION			/*for(var i:int = 0; i < arr.length; i++)				{					for(var j:int = 0; j < usedArr.length; j++)					{												if(arr[i].charAt(0) === usedArr[j].charAt(0))						{							trace("-- Doppelte Gefunden und entfernt: " + arr[i]);							arr.splice(i, 1);							if(i > 0)i--;						}					}				}*/						// look for doubles and place duplicates in own array			/*for(var i:int = 0; i < arr.length - 1; i++)			{				for(var j:int = i + 1; j < arr.length; j++)				{					if(arr[i].getClipName.substring(0, 7) === arr[j].getClipName.substring(0, 7))					//if(arr[i].charAt(0) === arr[j].charAt(0))					{						allVersions.push(arr[j]);						arr.splice(j, 1);						j--;					}				}			}						// gets rid of the original of every duplicate			// this leaves an array of unique elements only, and an array with all elements that have multiple versions			if(arr.length > 1)			{				for(var i:int = 0; i < arr.length; i++)				{					for(var j:int = 0; j < allVersions.length; j++)					{						if(arr[i].getClipName.substring(0, 7) === allVersions[j].getClipName.substring(0, 7))						//if(arr[i].charAt(0) === allVersions[j].charAt(0))						{							allVersions.push(arr[i]);							arr.splice(i, 1);							i--;							trace("yeah");						}									}				}			}						//sort array			allVersions.sortOn("getClipName", Array.DESCENDING);									//put all version groups in their own array			for(var i:int = 0; i < allVersions.length - 1; i++)			{				if(allVersions[i].getClipName.substring(0, 7) === allVersions[i + 1].getClipName.substring(0, 7))				//if(allVersions[i].charAt(0) === allVersions[i + 1].charAt(0))				{					allVersionsSorted[k].push(allVersions[i]);				}				else				{					allVersionsSorted[k].push(allVersions[i]);					k++;					allVersionsSorted[k] = new Array();				}			}						if(allVersionsSorted.length > 1)			{				//choose one out of each group and put it pack in the original array				for(var i:int = 0; i < allVersionsSorted.length; i++)				{					arr.push(allVersionsSorted[i][Utils.randRound(allVersionsSorted[i].length)]);				}			}									//TRACE THE TEST			for (var i:int = 0; i < allVersions.length; i++)			{				trace("allVersions: " + allVersions[i].getClipName); 			}							for (var i:int = 0; i < allVersionsSorted.length; i++)			{				trace("allVersionsSorted 2D groups: " + allVersionsSorted[i]); 			}*/   					}	}}